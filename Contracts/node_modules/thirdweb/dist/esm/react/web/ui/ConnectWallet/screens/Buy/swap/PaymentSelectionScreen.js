import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { IdCardIcon } from "@radix-ui/react-icons";
import { useQuery } from "@tanstack/react-query";
import { getCachedChain } from "../../../../../../../chains/utils.js";
import { NATIVE_TOKEN_ADDRESS } from "../../../../../../../constants/addresses.js";
import { getWalletBalance, } from "../../../../../../../wallets/utils/getWalletBalance.js";
import { useCustomTheme } from "../../../../../../core/design-system/CustomThemeProvider.js";
import { iconSize, radius, spacing, } from "../../../../../../core/design-system/index.js";
import { useChainMetadata } from "../../../../../../core/hooks/others/useChainQuery.js";
import { useActiveAccount } from "../../../../../../core/hooks/wallets/useActiveAccount.js";
import { useConnectedWallets } from "../../../../../../core/hooks/wallets/useConnectedWallets.js";
import { LoadingScreen } from "../../../../../wallets/shared/LoadingScreen.js";
import { Spacer } from "../../../../components/Spacer.js";
import { Container } from "../../../../components/basic.js";
import { Button } from "../../../../components/buttons.js";
import { Text } from "../../../../components/text.js";
import { OutlineWalletIcon } from "../../../icons/OutlineWalletIcon.js";
import { isNativeToken } from "../../nativeToken.js";
import { WalletRowWithBalances } from "../WalletSelectorButton.js";
export function PaymentSelectionScreen(props) {
    const theme = useCustomTheme();
    const connectedWallets = useConnectedWallets();
    // if all wallets are connected and showAll wallets is disabled, hide the connect button
    const hideConnectButton = !props.showAllWallets &&
        props.wallets?.every((w) => connectedWallets.includes(w));
    const chainInfo = useChainMetadata(props.toChain);
    const activeAccount = useActiveAccount();
    const walletsAndBalances = useQuery({
        queryKey: [
            "wallets-and-balances",
            connectedWallets.map((w) => w.getAccount()?.address),
            props.sourceSupportedTokens,
            props.toChain.id,
            props.toToken,
            props.tokenAmount,
            props.mode,
            activeAccount?.address,
        ],
        queryFn: async () => {
            // in parallel, get the balances of all the wallets on each of the sourceSupportedTokens
            const walletBalanceMap = new Map();
            const balancePromises = connectedWallets.flatMap((wallet) => {
                const account = wallet.getAccount();
                if (!account)
                    return [];
                walletBalanceMap.set(wallet, []);
                // inject the destination token too since it can be used as well to pay/transfer
                const toToken = isNativeToken(props.toToken)
                    ? {
                        address: NATIVE_TOKEN_ADDRESS,
                        name: chainInfo.data?.nativeCurrency.name || "",
                        symbol: chainInfo.data?.nativeCurrency.symbol || "",
                        icon: chainInfo.data?.icon?.url,
                    }
                    : props.toToken;
                const tokens = {
                    ...props.sourceSupportedTokens,
                    [props.toChain.id]: [
                        toToken,
                        ...(props.sourceSupportedTokens?.[props.toChain.id] || []),
                    ],
                };
                return Object.entries(tokens).flatMap(([chainId, tokens]) => {
                    return tokens.map(async (token) => {
                        try {
                            const chain = getCachedChain(Number(chainId));
                            const balance = await getWalletBalance({
                                address: account.address,
                                chain,
                                tokenAddress: isNativeToken(token) ? undefined : token.address,
                                client: props.client,
                            });
                            // show the token if:
                            // - its not the destination token and balance is greater than 0
                            // - its the destination token and balance is greater than the token amount AND we the account is not the default account in fund_wallet mode
                            const shouldInclude = token.address === toToken.address &&
                                chain.id === props.toChain.id
                                ? props.mode === "fund_wallet" &&
                                    account.address === activeAccount?.address
                                    ? false
                                    : Number(balance.displayValue) > Number(props.tokenAmount)
                                : balance.value > 0n;
                            if (shouldInclude) {
                                const existingBalances = walletBalanceMap.get(wallet) || [];
                                existingBalances.push({ balance, chain, token });
                                existingBalances.sort((a, b) => {
                                    if (a.chain.id === props.toChain.id &&
                                        a.token.address === toToken.address)
                                        return -1;
                                    if (b.chain.id === props.toChain.id &&
                                        b.token.address === toToken.address)
                                        return 1;
                                    if (a.chain.id === props.toChain.id)
                                        return -1;
                                    if (b.chain.id === props.toChain.id)
                                        return 1;
                                    return a.chain.id > b.chain.id ? 1 : -1;
                                });
                            }
                        }
                        catch (error) {
                            console.error(`Failed to fetch balance for wallet ${wallet.id} on chain ${chainId} for token ${token.symbol}:`, error);
                        }
                    });
                });
            });
            await Promise.all(balancePromises);
            return walletBalanceMap;
        },
        enabled: !!props.sourceSupportedTokens && !!chainInfo.data,
    });
    if (walletsAndBalances.isLoading || !walletsAndBalances.data) {
        return _jsx(LoadingScreen, {});
    }
    return (_jsxs(Container, { children: [_jsxs(Container, { flex: "column", gap: "xs", children: [Array.from(walletsAndBalances.data?.entries() || [])
                        .filter(([w]) => !props.hiddenWallets?.includes(w.id))
                        .map(([w, balances]) => {
                        const address = w.getAccount()?.address;
                        if (!address)
                            return null;
                        return (_jsx(WalletRowWithBalances, { wallet: w, balances: balances, client: props.client, address: address, onClick: props.onSelect }, w.id));
                    }), !hideConnectButton && (_jsx(Button, { variant: "secondary", fullWidth: true, onClick: props.onConnect, gap: "xs", bg: "tertiaryBg", style: {
                            borderRadius: radius.lg,
                            border: `1px solid ${theme.colors.borderColor}`,
                            padding: spacing.sm,
                        }, children: _jsxs(Container, { flex: "row", gap: "sm", center: "y", expand: true, color: "secondaryIconColor", children: [_jsx(OutlineWalletIcon, { size: iconSize.md }), _jsx(Text, { size: "sm", color: "primaryText", children: "Pay with another wallet" })] }) })), props.payWithFiatEnabled && (_jsx(Button, { variant: "secondary", fullWidth: true, gap: "xs", bg: "tertiaryBg", onClick: props.onSelectFiat, style: {
                            borderRadius: radius.lg,
                            border: `1px solid ${theme.colors.borderColor}`,
                            padding: spacing.sm,
                        }, children: _jsxs(Container, { flex: "row", gap: "sm", center: "y", expand: true, color: "secondaryIconColor", children: [_jsx(IdCardIcon, { style: {
                                        width: iconSize.md,
                                        height: iconSize.md,
                                    } }), _jsx(Text, { size: "sm", color: "primaryText", children: "Pay with credit card" })] }) }))] }), _jsx(Spacer, { y: "sm" })] }));
}
//# sourceMappingURL=PaymentSelectionScreen.js.map