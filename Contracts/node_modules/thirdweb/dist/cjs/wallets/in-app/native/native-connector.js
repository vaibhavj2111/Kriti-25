"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InAppNativeConnector = void 0;
const json_js_1 = require("../../../utils/json.js");
const nativeStorage_js_1 = require("../../../utils/storage/nativeStorage.js");
const get_enclave_user_status_js_1 = require("../core/actions/get-enclave-user-status.js");
const authEndpoint_js_1 = require("../core/authentication/authEndpoint.js");
const backend_js_1 = require("../core/authentication/backend.js");
const client_scoped_storage_js_1 = require("../core/authentication/client-scoped-storage.js");
const guest_js_1 = require("../core/authentication/guest.js");
const jwt_js_1 = require("../core/authentication/jwt.js");
const linkAccount_js_1 = require("../core/authentication/linkAccount.js");
const passkeys_js_1 = require("../core/authentication/passkeys.js");
const siwe_js_1 = require("../core/authentication/siwe.js");
const enclave_wallet_js_1 = require("../core/wallet/enclave-wallet.js");
const otp_js_1 = require("../web/lib/auth/otp.js");
const native_auth_js_1 = require("./auth/native-auth.js");
const logout_js_1 = require("./helpers/auth/logout.js");
const sharded_wallet_js_1 = require("./helpers/wallet/sharded-wallet.js");
class InAppNativeConnector {
    constructor(options) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ecosystem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "storage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "passkeyDomain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "wallet", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = options.client;
        this.passkeyDomain = options.passkeyDomain;
        this.ecosystem = options.ecosystem;
        this.storage = new client_scoped_storage_js_1.ClientScopedStorage({
            storage: nativeStorage_js_1.nativeLocalStorage,
            clientId: this.client.clientId,
            ecosystem: options.ecosystem,
        });
    }
    async initializeWallet(authResult, encryptionKey) {
        const storedAuthToken = await this.storage.getAuthCookie();
        if (!authResult && storedAuthToken === null) {
            throw new Error("No auth token provided and no stored auth token found to initialize the wallet");
        }
        const user = await (0, get_enclave_user_status_js_1.getUserStatus)({
            authToken: authResult?.storedToken.cookieString || storedAuthToken,
            client: this.client,
            ecosystem: this.storage.ecosystem,
        });
        if (!user) {
            throw new Error("Cannot initialize wallet, no user logged in");
        }
        let wallet = user.wallets[0];
        if (authResult && wallet && wallet.type === "sharded") {
            try {
                const { migrateToEnclaveWallet } = await Promise.resolve().then(() => require("./helpers/wallet/migration.js"));
                wallet = await migrateToEnclaveWallet({
                    client: this.client,
                    storage: this.storage,
                    storedToken: authResult.storedToken,
                    encryptionKey,
                });
            }
            catch {
                console.warn("Failed to migrate from sharded to enclave wallet, continuing with sharded wallet");
            }
        }
        if (authResult && !wallet) {
            // new user, generate enclave wallet
            const { generateWallet } = await Promise.resolve().then(() => require("../core/actions/generate-wallet.enclave.js"));
            wallet = await generateWallet({
                authToken: authResult.storedToken.cookieString,
                client: this.client,
                ecosystem: this.ecosystem,
            });
        }
        if (wallet && wallet.type === "enclave") {
            this.wallet = new enclave_wallet_js_1.EnclaveWallet({
                client: this.client,
                ecosystem: this.ecosystem,
                address: wallet.address,
                storage: this.storage,
            });
        }
        else {
            this.wallet = new sharded_wallet_js_1.ShardedWallet({
                client: this.client,
                storage: this.storage,
            });
        }
    }
    async getUser() {
        if (!this.wallet) {
            const localAuthToken = await this.storage.getAuthCookie();
            if (!localAuthToken) {
                return { status: "Logged Out" };
            }
            await this.initializeWallet();
        }
        if (!this.wallet) {
            throw new Error("Wallet not initialized");
        }
        return this.wallet.getUserWalletStatus();
    }
    getAccount() {
        if (!this.wallet) {
            throw new Error("Wallet not initialized");
        }
        return this.wallet.getAccount();
    }
    preAuthenticate(args) {
        return (0, otp_js_1.sendOtp)({
            ...args,
            client: this.client,
        });
    }
    async authenticate(params) {
        const strategy = params.strategy;
        switch (strategy) {
            case "email":
            case "phone": {
                return (0, otp_js_1.verifyOtp)(params);
            }
            case "guest": {
                return (0, guest_js_1.guestAuthenticate)({
                    client: this.client,
                    ecosystem: params.ecosystem,
                    storage: nativeStorage_js_1.nativeLocalStorage,
                });
            }
            case "backend": {
                return (0, backend_js_1.backendAuthenticate)({
                    client: this.client,
                    walletSecret: params.walletSecret,
                    ecosystem: params.ecosystem,
                });
            }
            case "wallet": {
                return (0, siwe_js_1.siweAuthenticate)({
                    client: this.client,
                    wallet: params.wallet,
                    chain: params.chain,
                    ecosystem: params.ecosystem,
                });
            }
            case "github":
            case "twitch":
            case "steam":
            case "farcaster":
            case "telegram":
            case "google":
            case "facebook":
            case "discord":
            case "line":
            case "x":
            case "apple": {
                const ExpoLinking = require("expo-linking");
                const redirectUrl = params.redirectUrl || ExpoLinking.createURL("");
                return (0, native_auth_js_1.socialAuth)({
                    auth: { strategy, redirectUrl },
                    client: this.client,
                    ecosystem: this.ecosystem,
                });
            }
            case "passkey":
                return this.passkeyAuth(params);
            case "jwt":
                return (0, jwt_js_1.customJwt)({
                    jwt: params.jwt,
                    client: this.client,
                    ecosystem: this.ecosystem,
                });
            case "auth_endpoint":
                return (0, authEndpoint_js_1.authEndpoint)({
                    payload: params.payload,
                    client: this.client,
                    ecosystem: this.ecosystem,
                });
            default:
                throw new Error(`Unsupported authentication type: ${strategy}`);
        }
    }
    async connect(params) {
        const authResult = await this.authenticate({
            ...params,
            client: this.client,
            ecosystem: this.ecosystem,
        });
        const encryptionKey = params.strategy === "jwt"
            ? params.encryptionKey
            : params.strategy === "auth_endpoint"
                ? params.encryptionKey
                : undefined;
        await this.initializeWallet(authResult, encryptionKey);
        if (!this.wallet) {
            throw new Error("Wallet not initialized");
        }
        await this.wallet.postWalletSetUp({
            ...authResult,
            encryptionKey,
        });
        const account = await this.getAccount();
        return {
            user: {
                status: "Logged In, Wallet Initialized",
                account,
                authDetails: authResult.storedToken.authDetails,
                walletAddress: account.address,
            },
        };
    }
    async passkeyAuth(args) {
        const { type, passkeyName, client, ecosystem, storeLastUsedPasskey = true, } = args;
        const domain = this.passkeyDomain;
        const storage = this.storage;
        if (!domain) {
            throw new Error("Passkey domain is required for native platforms. Please pass it in the 'auth' options when creating the inAppWallet().");
        }
        try {
            const { PasskeyNativeClient } = await Promise.resolve().then(() => require("./auth/passkeys.js"));
            const passkeyClient = new PasskeyNativeClient();
            let authToken;
            if (type === "sign-up") {
                authToken = await (0, passkeys_js_1.registerPasskey)({
                    client,
                    ecosystem,
                    username: passkeyName,
                    passkeyClient,
                    storage: storeLastUsedPasskey ? storage : undefined,
                    rp: {
                        id: domain,
                        name: domain,
                    },
                });
            }
            else {
                authToken = await (0, passkeys_js_1.loginWithPasskey)({
                    client,
                    ecosystem,
                    passkeyClient,
                    storage: storeLastUsedPasskey ? storage : undefined,
                    rp: {
                        id: domain,
                        name: domain,
                    },
                });
            }
            return authToken;
        }
        catch (error) {
            console.error(`Error while signing in with passkey. ${error?.message || typeof error === "object" ? (0, json_js_1.stringify)(error) : error}`);
            if (error instanceof Error) {
                throw new Error(`Error signing in with passkey: ${error.message}`);
            }
            throw new Error("An unknown error occurred signing in with passkey");
        }
    }
    // TODO (rn) expose in the interface
    async deleteActiveAccount() {
        return (0, native_auth_js_1.deleteActiveAccount)({
            client: this.client,
            storage: this.storage,
        });
    }
    logout() {
        return (0, logout_js_1.logoutUser)({
            client: this.client,
            storage: this.storage,
        });
    }
    async linkProfile(args) {
        const { storedToken } = await this.authenticate(args);
        return await (0, linkAccount_js_1.linkAccount)({
            client: args.client,
            tokenToLink: storedToken.cookieString,
            storage: this.storage,
            ecosystem: args.ecosystem || this.ecosystem,
        });
    }
    async unlinkProfile(profile) {
        return await (0, linkAccount_js_1.unlinkAccount)({
            client: this.client,
            ecosystem: this.ecosystem,
            storage: this.storage,
            profileToUnlink: profile,
        });
    }
    async getProfiles() {
        return (0, linkAccount_js_1.getLinkedProfilesInternal)({
            client: this.client,
            ecosystem: this.ecosystem,
            storage: this.storage,
        });
    }
}
exports.InAppNativeConnector = InAppNativeConnector;
//# sourceMappingURL=native-connector.js.map